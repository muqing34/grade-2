<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>遊戲進行中 - 心理文字遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* 強制覆蓋 input[type=number] 的箭頭 (部分瀏覽器) */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield; /* Firefox */
        }
         /* 簡單的加載/保存反饋樣式 */
        .feedback-message {
            position: fixed;
            top: 80px; /* 導航欄下方 */
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 8px;
            color: white;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-out;
            pointer-events: none; /* 防止遮擋按鈕 */
        }
        .feedback-message.show {
            opacity: 1;
        }
        .feedback-message.success { background-color: rgba(74, 222, 128, 0.8); } /* green-400 */
        .feedback-message.error { background-color: rgba(248, 113, 113, 0.8); } /* red-400 */

        /* (新) 彈窗樣式 */
        .modal {
            transition: opacity 0.25s ease;
        }
        .modal-content {
            transition: transform 0.25s ease;
        }
        /* (新) 報告文本樣式 */
        #report-content {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            padding: 1rem;
            border-radius: 0.5rem;
            white-space: pre-wrap; /* 保持換行和空格 */
            line-height: 1.6;
        }
    </style>
</head>
<body class="bg-white text-gray-900 min-h-screen">

<!-- 導航欄 -->
<nav class="bg-gray-100 shadow-md">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between h-16">
            <div class="flex">
                <div class="flex-shrink-0 flex items-center text-xl font-bold text-blue-600">
                    心理冒險
                </div>
                <div class="hidden sm:ml-6 sm:flex sm:space-x-8">
                    <a href="game.html" class="border-blue-500 text-gray-900 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                        遊戲
                    </a>
                    <a href="ai-chat.html" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                        AI助手
                    </a>
                    <a href="knowledge.html" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                        心理科普
                    </a>
                    <a href="profile.html" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium">
                        個人資料
                    </a>
                </div>
            </div>
            <div class="flex items-center">
                <button id="logout-button" class="bg-red-600 text-white px-3 py-1.5 rounded-md text-sm font-medium hover:bg-red-700 transition">
                    登出
                </button>
            </div>
        </div>
    </div>
</nav>

<!-- 反饋消息容器 -->
<div id="feedback-container"></div>

<!-- 遊戲內容區 -->
<div class="max-w-3xl mx-auto p-4 sm:p-6 lg:p-8 mt-6">

    <!-- 1. 遊戲開始菜單 (默認隱藏) -->
    <div id="game-start-menu" class="hidden">
        <div class="bg-white shadow-xl rounded-lg p-6">
            <h1 class="text-3xl font-bold text-blue-600 mb-4 text-center">心智試煉</h1>
            <p class="text-gray-600 mb-6 text-center">在開始之前，請確定你的初始心靈屬性。</p>

            <!-- 屬性分配模式選擇 -->
            <div class="mb-6 text-center">
                <label class="mr-4">
                    <input type="radio" name="attrMode" value="roll" checked onchange="toggleAttributeMode('roll')"> 隨機擲骰
                </label>
                <label>
                    <input type="radio" name="attrMode" value="manual" onchange="toggleAttributeMode('manual')"> 手動分配 (共15點)
                </label>
            </div>

            <!-- 屬性顯示/輸入 -->
            <div id="start-attributes-section" class="mb-6">
                <!-- 隨機模式 -->
                <div id="roll-mode-attributes" class="grid grid-cols-3 gap-4">
                    <!-- 初始屬性將加載於此 -->
                </div>
                <!-- 手動模式 (默認隱藏) -->
                <div id="manual-mode-attributes" class="hidden grid grid-cols-3 gap-4 items-center">
                    <div>
                        <label for="manual-insight" class="block text-sm font-medium text-gray-700 text-center">洞察力</label>
                        <input type="number" id="manual-insight" name="insight" min="1" max="10" value="5" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-center text-xl font-bold" oninput="updateManualPoints()">
                    </div>
                    <div>
                        <label for="manual-resolve" class="block text-sm font-medium text-gray-700 text-center">決心</label>
                        <input type="number" id="manual-resolve" name="resolve" min="1" max="10" value="5" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-center text-xl font-bold" oninput="updateManualPoints()">
                    </div>
                    <div>
                        <label for="manual-empathy" class="block text-sm font-medium text-gray-700 text-center">同理心</label>
                        <input type="number" id="manual-empathy" name="empathy" min="1" max="10" value="5" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-center text-xl font-bold" oninput="updateManualPoints()">
                    </div>
                </div>
                <p id="manual-points-info" class="text-center text-sm mt-2 text-red-600 hidden"></p>
            </div>

            <!-- (新) 操作按鈕: 讀檔按鈕現在默認顯示 -->
            <button id="load-game-start-button"
                    class="w-full mb-4 px-4 py-3 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 transition
                           disabled:bg-gray-400 disabled:cursor-not-allowed"
                    disabled>
                讀取存檔 (無存檔)
            </button>
            <button id="roll-attributes-button" class="w-full mb-4 px-4 py-3 font-semibold text-white bg-yellow-600 rounded-md hover:bg-yellow-700 transition">
                隨機屬性 (總點數15)
            </button>
            <button id="start-adventure-button" class="w-full px-4 py-3 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 transition">
                開始冒險
            </button>
            <p id="start-error-message" class="text-center text-sm mt-2 text-red-600 hidden"></p>
        </div>
    </div>

    <!-- 2. 遊戲主界面 (默認隱藏) -->
    <div id="game-main-ui" class="hidden space-y-6">
        <!-- 玩家狀態 -->
        <div class="bg-white shadow-lg rounded-lg p-6">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold text-blue-700">玩家狀態</h3>
                <!-- 存檔/讀檔按鈕 -->
                <div class="space-x-2">
                    <button id="save-game-button" class="px-3 py-1 text-sm font-medium text-white bg-green-500 rounded-md hover:bg-green-600 transition">存檔</button>
                    <button id="load-game-button" class="px-3 py-1 text-sm font-medium text-white bg-yellow-500 rounded-md hover:bg-yellow-600 transition">讀檔</button>
                </div>
            </div>
            <div id="game-attributes-list" class="grid grid-cols-3 gap-4">
                <!-- 遊戲屬性將加載於此 -->
            </div>
        </div>

        <!-- 遊戲節點 -->
        <div class="bg-white shadow-lg rounded-lg p-6 min-h-[300px]">
            <div id="game-content" class="text-gray-700 leading-relaxed mb-6 text-lg">
                <p>正在加載遊戲內容...</p>
            </div>

            <div id="choices-list" class="space-y-3">
                <!-- 選項將動態插入這裡 -->
            </div>
        </div>
        <!-- 遊戲重置按鈕 -->
        <div class="text-center mt-6">
            <button id="reset-game-button" class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300 transition">
                重置遊戲
            </button>
        </div>
    </div>

    <!-- 3. 遊戲結束畫面 (默認隱藏) -->
    <div id="game-finish-screen" class="hidden">
        <div class="bg-white shadow-xl rounded-lg p-6 text-center">
            <h1 class="text-4xl font-bold text-green-600 mb-4">試煉完成</h1>
            <p id="game-end-message" class="text-gray-700 mb-6 text-lg">你達成了結局。</p>

            <!-- (已更新) 按鈕布局 -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- (已更新) 按鈕 1: 查看報告 -->
                <button id="view-report-button"
                        class="w-full px-4 py-3 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 transition">
                    查看報告
                </button>
                <!-- (已更新) 按鈕 2: 重新開始 -->
                <button id="restart-button" class="w-full px-4 py-3 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 transition">
                    重新開始
                </button>
            </div>
            <!-- 報告下載的消息提示 -->
            <div id="download-message-finish" class="mt-4 hidden p-3 rounded-lg"></div>
        </div>
    </div>

</div>

<!-- (新) 報告彈窗 (Modal) -->
<div id="report-modal" class="modal fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 opacity-0 pointer-events-none">
    <div class="modal-content bg-white rounded-lg shadow-xl w-full max-w-2xl transform -translate-y-10 scale-95">
        <!-- 彈窗頭部 -->
        <div class="flex justify-between items-center p-4 border-b">
            <h3 class="text-2xl font-semibold text-gray-900">遊戲報告</h3>
            <button id="modal-close" class="text-gray-400 hover:text-gray-600 text-3xl">&times;</button>
        </div>
        <!-- 彈窗內容 -->
        <div class="p-6 max-h-[70vh] overflow-y-auto">
            <pre id="report-content" class="text-gray-700">正在生成報告...</pre>
        </div>
        <!-- 彈窗底部 -->
        <div class="p-4 bg-gray-50 rounded-b-lg flex justify-between items-center">
            <button id="download-report-modal-button" class="px-4 py-2 font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 transition">
                下載報告
            </button>
            <button id="modal-close-bottom" class="px-4 py-2 font-semibold text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300 transition">
                關閉
            </button>
        </div>
    </div>
</div>


<!-- 全局JS -->
<script>
    // --- 認證與API工具 ---
    const API_BASE = '';

    function getToken() {
        return localStorage.getItem('jwtToken');
    }

    function logout() {
        localStorage.removeItem('jwtToken');
        window.location.href = '/index.html';
    }

    function checkAuth() {
        if (!getToken()) {
            console.log('未找到Token，正在重定向到登錄頁...');
            logout();
        }
    }

    async function fetchWithAuth(url, options = {}) {
        const token = getToken();
        if (!token) {
            logout();
            throw new Error('用戶未認證');
        }

        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`,
            ...options.headers,
        };

        const response = await fetch(API_BASE + url, { ...options, headers });

        if (response.status === 401 || response.status === 403) {
            logout();
            throw new Error('認證失敗，請重新登錄');
        }
        return response;
    }

    // --- 頁面元素 ---
    const startMenu = document.getElementById('game-start-menu');
    const gameUI = document.getElementById('game-main-ui');
    const finishScreen = document.getElementById('game-finish-screen');

    const rollModeAttributes = document.getElementById('roll-mode-attributes');
    const manualModeAttributes = document.getElementById('manual-mode-attributes');
    const manualPointsInfo = document.getElementById('manual-points-info');
    const startErrorMessage = document.getElementById('start-error-message');

    const gameAttributesList = document.getElementById('game-attributes-list');

    const gameContent = document.getElementById('game-content');
    const choicesList = document.getElementById('choices-list');
    const gameEndMessage = document.getElementById('game-end-message');

    const rollButton = document.getElementById('roll-attributes-button');
    const startButton = document.getElementById('start-adventure-button');
    const restartButton = document.getElementById('restart-button');
    const resetGameButton = document.getElementById('reset-game-button');
    const saveGameButton = document.getElementById('save-game-button');
    const loadGameButton = document.getElementById('load-game-button');
    const loadGameStartButton = document.getElementById('load-game-start-button');
    const feedbackContainer = document.getElementById('feedback-container');

    // (新) 遊戲結束頁的按鈕
    const viewReportButton = document.getElementById('view-report-button');
    const downloadMessageFinish = document.getElementById('download-message-finish');

    // (新) 報告彈窗元素
    const reportModal = document.getElementById('report-modal');
    const reportContent = document.getElementById('report-content');
    const modalClose = document.getElementById('modal-close');
    const modalCloseBottom = document.getElementById('modal-close-bottom');
    const downloadReportModalButton = document.getElementById('download-report-modal-button');

    // --- 頁面邏輯 ---
    let currentAttributeMode = 'roll'; // 'roll' or 'manual'

    document.addEventListener('DOMContentLoaded', () => {
        checkAuth();

        document.getElementById('logout-button').addEventListener('click', logout);
        rollButton.addEventListener('click', rollAttributes);
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', resetGameAndReload);
        resetGameButton.addEventListener('click', resetGameAndReload);
        saveGameButton.addEventListener('click', saveGame);
        loadGameButton.addEventListener('click', loadGame);
        loadGameStartButton.addEventListener('click', loadGame);

        // (新) 綁定報告按鈕
        viewReportButton.addEventListener('click', handleViewReport);
        downloadReportModalButton.addEventListener('click', handleReportDownload);
        modalClose.onclick = closeModal;
        modalCloseBottom.onclick = closeModal;
        reportModal.onclick = (e) => {
            if (e.target === reportModal) closeModal();
        };

        // 初始加載
        loadInitialState();
    });

    // 檢查遊戲是否已開始
    async function loadInitialState() {
        clearError(startErrorMessage);
        try {
            const state = await getGameState();

             // (需求1: 已更新) 檢查是否有存檔
            if (state.lastSaveNodeId && state.lastSaveNodeId !== "START") {
                 loadGameStartButton.disabled = false; // 啟用按鈕
                 loadGameStartButton.textContent = "讀取存檔";
            } else {
                 loadGameStartButton.disabled = true; // 禁用按鈕
                 loadGameStartButton.textContent = "讀取存檔 (無存檔)";
            }

            if (state.currentNodeId === "START") {
                showStartMenu(state.attributes);
                updateManualPoints();
            } else {
                 const node = await getCurrentNodeFromServer();
                 if (node.choices && node.choices.length > 0) {
                     renderAttributes(state.attributes, gameAttributesList);
                     renderGameNode(node);
                     showGameUI();
                 } else {
                     showFinishScreen(node.content);
                 }
            }
        } catch (error) {
            console.error('加載初始狀態失敗:', error);
            showError(startErrorMessage, error.message || '加載遊戲失敗');
        }
    }

    // --- 屏幕切換與模式切換 ---
    function showStartMenu(attrs) {
        renderAttributes(attrs, rollModeAttributes);
        startMenu.classList.remove('hidden');
        gameUI.classList.add('hidden');
        finishScreen.classList.add('hidden');
    }

    function showGameUI() {
        startMenu.classList.add('hidden');
        gameUI.classList.remove('hidden');
        finishScreen.classList.add('hidden');
    }

    function showFinishScreen(endMessage) {
        gameEndMessage.innerHTML = endMessage.replace(/\(.*\)/, '<span class="text-yellow-600 font-semibold">$&</span>'); // 高亮結局
        startMenu.classList.add('hidden');
        gameUI.classList.add('hidden');
        finishScreen.classList.remove('hidden');
    }

    function toggleAttributeMode(mode) {
        currentAttributeMode = mode;
        clearError(startErrorMessage);
        if (mode === 'roll') {
            rollModeAttributes.classList.remove('hidden');
            manualModeAttributes.classList.add('hidden');
            manualPointsInfo.classList.add('hidden');
            rollButton.classList.remove('hidden');
            startButton.disabled = false;
        } else {
            rollModeAttributes.classList.add('hidden');
            manualModeAttributes.classList.remove('hidden');
            manualPointsInfo.classList.remove('hidden');
            rollButton.classList.add('hidden');
            updateManualPoints();
        }
    }

    // --- API 調用與邏輯 ---
    async function getGameState() {
        const response = await fetchWithAuth('/api/game/state');
        if (!response.ok) throw new Error('無法加載遊戲狀態');
        return await response.json();
    }

    async function getCurrentNodeFromServer() {
         const response = await fetchWithAuth('/api/game/current-node');
         if (!response.ok) throw new Error('無法加載當前節點');
         return await response.json();
    }


    async function rollAttributes() {
        rollButton.disabled = true;
        rollButton.textContent = "擲骰中...";
        clearError(startErrorMessage);
        try {
            const response = await fetchWithAuth('/api/game/roll-attributes', { method: 'POST' });
            if (!response.ok) throw new Error('擲骰失敗');
            const state = await response.json();
            renderAttributes(state.attributes, rollModeAttributes);
        } catch (error) {
            console.error('擲骰失敗:', error);
            showError(startErrorMessage, error.message);
        } finally {
            rollButton.disabled = false;
            rollButton.textContent = "隨機屬性 (總點數15)";
        }
    }

    function updateManualPoints() {
        const insight = parseInt(document.getElementById('manual-insight').value) || 0;
        const resolve = parseInt(document.getElementById('manual-resolve').value) || 0;
        const empathy = parseInt(document.getElementById('manual-empathy').value) || 0;
        const total = insight + resolve + empathy;
        const minVal = 1;
        const maxVal = 10;

        let isValid = true;
        let message = `當前總點數: ${total} / 15`;

        if (total !== 15) {
            isValid = false;
            message += " (必須等於 15)";
        }
        if (insight < minVal || insight > maxVal || resolve < minVal || resolve > maxVal || empathy < minVal || empathy > maxVal) {
             isValid = false;
             message += ` (每項需在 ${minVal}-${maxVal} 之間)`;
        }

        manualPointsInfo.textContent = message;
        manualPointsInfo.classList.toggle('text-red-600', !isValid);
        manualPointsInfo.classList.toggle('text-green-600', isValid);
        startButton.disabled = !isValid;
    }


    async function startGame() {
        clearError(startErrorMessage);
        startButton.disabled = true;
        startButton.textContent = "正在開始...";

        try {
            let state;
            if (currentAttributeMode === 'manual') {
                const insight = parseInt(document.getElementById('manual-insight').value);
                const resolve = parseInt(document.getElementById('manual-resolve').value);
                const empathy = parseInt(document.getElementById('manual-empathy').value);
                const attributes = { insight, resolve, empathy };

                const setResponse = await fetchWithAuth('/api/game/set-attributes', {
                    method: 'POST',
                    body: JSON.stringify(attributes)
                });
                if (!setResponse.ok) {
                    const errorText = await setResponse.text();
                    throw new Error(`設置屬性失敗: ${errorText}`);
                }
                state = await setResponse.json();
            } else {
                state = await getGameState();
            }

            renderAttributes(state.attributes, gameAttributesList);
            const node = await getCurrentNodeFromServer();
            renderGameNode(node);
            showGameUI();

        } catch (error) {
            console.error("開始遊戲失敗:", error);
            showError(startErrorMessage, error.message);
            startButton.disabled = false;
            startButton.textContent = "開始冒險";
             if (currentAttributeMode === 'manual') {
                 updateManualPoints();
             }
        }
    }

    async function makeChoice(choiceId) {
        if (choiceId === 'FAIL_BACK') {
            try {
                const node = await getCurrentNodeFromServer();
                renderGameNode(node);
            } catch (error) {
                console.error('返回失敗:', error);
                gameContent.innerHTML = `<p class="text-red-500">${error.message}</p>`;
            }
            return;
        }

        try {
            const response = await fetchWithAuth('/api/game/choice', {
                method: 'POST',
                body: JSON.stringify({ choiceId }),
            });

            const node = await response.json();

            if (!response.ok) {
                if (response.status === 400 && node && node.nodeId === "FAILURE") {
                    renderGameNode(node);
                    return;
                }
                 const errorText = node ? JSON.stringify(node) : await response.text();
                throw new Error(`選擇失敗 (${response.status}): ${errorText}`);
            }

            renderGameNode(node);
            const state = await getGameState();
            renderAttributes(state.attributes, gameAttributesList);

        } catch (error) {
            console.error('選擇時發生錯誤:', error);
            gameContent.innerHTML = `<p class="text-red-500">${error.message}</p>`;
        }
    }

    async function resetGameAndReload() {
        if (!confirm('確定要重置遊戲嗎？所有進度將丟失。')) {
            return;
        }
        try {
            await fetchWithAuth('/api/game/reset', { method: 'POST' });
            window.location.reload();
        } catch (error) {
            console.error('重置遊戲失敗:', error);
            showFeedback('重置遊戲失敗', 'error');
        }
    }

    // --- 存檔/讀檔 ---
    async function saveGame() {
        saveGameButton.disabled = true;
        try {
            const response = await fetchWithAuth('/api/game/save', { method: 'POST' });
            if (response.ok) {
                showFeedback('遊戲已保存', 'success');
                 // (新) 更新開始菜單的讀檔按鈕狀態
                 loadGameStartButton.disabled = false;
                 loadGameStartButton.textContent = "讀取存檔";
            } else {
                 throw new Error('存檔失敗');
            }
        } catch (error) {
             console.error('存檔失敗:', error);
             showFeedback('存檔失敗', 'error');
        } finally {
            saveGameButton.disabled = false;
        }
    }

    async function loadGame() {
        loadGameButton.disabled = true;
        loadGameStartButton.disabled = true; // 同時禁用開始菜單的按鈕
        try {
            const response = await fetchWithAuth('/api/game/load', { method: 'POST' });
            if (response.ok) {
                const loadedNode = await response.json();
                const state = await getGameState(); // 獲取讀檔後的最新狀態

                renderAttributes(state.attributes, gameAttributesList); // 更新屬性顯示
                renderGameNode(loadedNode); // 渲染讀檔的節點
                showGameUI(); // 確保顯示遊戲界面
                showFeedback('遊戲已讀取', 'success');
            } else {
                 throw new Error('讀檔失敗');
            }
        } catch (error) {
            console.error('讀檔失敗:', error);
             showFeedback('讀檔失敗', 'error');
             loadGameStartButton.disabled = false; // 讀檔失敗，重新啟用按鈕
        } finally {
             loadGameButton.disabled = false;
        }
    }


    // --- 渲染函數 ---
    function renderAttributes(attrs, element) {
        element.innerHTML = '';
        // (BUG 修復) 增加對 attrs 存在性的檢查
        if (!attrs || Object.keys(attrs).length === 0) {
            element.innerHTML = '<p class="text-gray-500">暫無屬性</p>';
            return;
        }

        const attrMap = {
            'insight': '洞察力',
            'resolve': '決心',
            'empathy': '同理心'
        };

        const attrOrder = ['insight', 'resolve', 'empathy'];

        attrOrder.forEach(key => {
            // (BUG 修復) 直接檢查 attrs.hasOwnProperty(key)
            if (attrs.hasOwnProperty(key)) {
                const value = attrs[key];
                const attrEl = document.createElement('div');
                attrEl.className = 'bg-gray-100 p-4 rounded-lg shadow-inner text-center';
                attrEl.innerHTML = `
                    <span class="text-gray-700 font-medium capitalize text-lg">${attrMap[key] || key}</span>
                    <span class="text-blue-600 font-bold text-3xl block mt-1">${value}</span>
                `;
                element.appendChild(attrEl);
            }
        });
    }


    function renderGameNode(node) {
        gameContent.innerHTML = `<p class="text-gray-800">${node.content.replace(/\n/g, '<br>')}</p>`;
        choicesList.innerHTML = '';

        if (!node.choices || node.choices.length === 0) {
            showFinishScreen(node.content);
            return;
        }

        node.choices.forEach(choice => {
            const choiceButton = document.createElement('button');
            choiceButton.className = 'w-full px-4 py-3 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 text-left shadow-md disabled:opacity-50 disabled:cursor-not-allowed';

            let text = choice.text;

            if (choice.requiredAttributes) {
                const attrMap = { 'insight': '洞察', 'resolve': '決心', 'empathy': '同理心' };
                let reqText = [];
                for (const [key, value] of Object.entries(choice.requiredAttributes)) {
                    reqText.push(`${attrMap[key] || key} > ${value-1}`);
                }
                text += ` <span class="text-xs text-blue-200">(${reqText.join(', ')})</span>`;
            }

            choiceButton.innerHTML = text;
            choiceButton.onclick = () => {
                 disableAllChoices();
                 makeChoice(choice.choiceId);
            };
            choicesList.appendChild(choiceButton);
        });
    }

    function disableAllChoices() {
        const buttons = choicesList.querySelectorAll('button');
        buttons.forEach(button => button.disabled = true);
    }

    // --- 輔助函數 ---
     function showError(element, message) {
        element.textContent = message;
        element.classList.remove('hidden');
    }

    function clearError(element) {
        element.textContent = '';
        element.classList.add('hidden');
    }

    function showFeedback(message, type = 'success') {
        const feedbackEl = document.createElement('div');
        feedbackEl.className = `feedback-message ${type}`;
        feedbackEl.textContent = message;
        feedbackContainer.appendChild(feedbackEl);

        void feedbackEl.offsetWidth;
        feedbackEl.classList.add('show');

        setTimeout(() => {
            feedbackEl.classList.remove('show');
            setTimeout(() => {
                feedbackEl.remove();
            }, 500);
        }, 2000);
    }

    // (新) --- 報告查看/下載 ---

    // (新) 需求 2: 查看報告
    async function handleViewReport() {
        showMessage(downloadMessageFinish, '正在生成報告...', 'success');
        reportContent.textContent = '正在生成報告...';
        openModal();

        try {
            const response = await fetchWithAuth('/api/files/download/report');
            if (!response.ok) {
                throw new Error('無法生成報告');
            }
            const reportText = await response.text();
            reportContent.textContent = reportText; // 將報告文本放入 <pre>
            showMessage(downloadMessageFinish, '報告已生成。', 'success');

        } catch (error) {
            console.error('查看報告失敗:', error);
            reportContent.textContent = `報告生成失敗: ${error.message}`;
            showMessage(downloadMessageFinish, '報告生成失敗。', 'error');
        }
    }

    // (新) 彈窗中的下載按鈕
    async function handleReportDownload() {
        const messageEl = downloadMessageFinish;
        showMessage(messageEl, '正在準備下載...', 'success');

        try {
            const response = await fetchWithAuth('/api/files/download/report');
            if (!response.ok) throw new Error('無法獲取報告');

            const disposition = response.headers.get('content-disposition');
            let filename = 'psychological-report.txt';
            if (disposition && disposition.indexOf('attachment') !== -1) {
                const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
                const matches = filenameRegex.exec(disposition);
                if (matches != null && matches[1]) {
                    filename = matches[1].replace(/['"]/g, '');
                }
            }

            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();

            showMessage(messageEl, '報告已開始下載。', 'success');

        } catch (error) {
            console.error('下載失敗:', error);
            showMessage(messageEl, '下載報告失敗。', 'error');
        }
    }

    // (新) --- 通用消息顯示 ---
    function showMessage(element, msg, type) {
        element.textContent = msg;
        if (type === 'success') {
            element.className = 'mt-4 p-3 rounded-lg text-green-700 bg-green-100';
        } else {
            element.className = 'mt-4 p-3 rounded-lg text-red-700 bg-red-100';
        }
    }

    // (新) --- 彈窗 Modal 邏輯 ---
    function openModal() {
        reportModal.classList.remove('opacity-0', 'pointer-events-none');
        reportModal.querySelector('.modal-content').classList.remove('-translate-y-10', 'scale-95');
    }

    function closeModal() {
        reportModal.classList.add('opacity-0', 'pointer-events-none');
        reportModal.querySelector('.modal-content').classList.add('-translate-y-10', 'scale-95');
    }

</script>
</body>
</html>